use anyhow::bail;
use anyhow::Result;
use libbpf_cargo::SkeletonBuilder;
use libbpf_rs::skel::OpenSkel;
use libbpf_rs::skel::Skel;
use libbpf_rs::PerfBufferBuilder;
use libbpf_rs::Program;
use libbpf_rs::RingBufferBuilder;
use libbpf_rs::{skel::SkelBuilder, ObjectBuilder};
use plain::Plain;
use simple::simple_types;
use simple::SimpleSkelBuilder;
use std::path::PathBuf;
use std::str;
use std::time::Duration;
use time::macros::format_description;
use time::OffsetDateTime;
#[path = "../simple.skel.rs"]
mod simple;

// Need to implement this because we are saying that it is safe to perform Plain operations
// on the memory where an event is stored
// https://docs.rs/plain/latest/plain/
// From the Plain docs:
// A type can be Plain if it is #repr(C) and only contains data with no possible invalid values.
//  - We are saying this is true because simple_types::event is generated from C code
//  - We are inherently trusting the author of libbpf-cargo to keep the memory intact
unsafe impl Plain for simple_types::event {}

fn handle_event(data: &[u8]) -> i32 {
    // This event type is only generated if a dummy global event ins instantiated in simple.bpf.c
    let mut event = simple_types::event::default();
    plain::copy_from_bytes(&mut event, data).expect("Data buffer was too short");

    let now = if let Ok(now) = OffsetDateTime::now_local() {
        let format = format_description!("[hour]:[minute]:[second]");
        now.format(&format)
            .unwrap_or_else(|_| "00:00:00".to_string())
    } else {
        "00:00:00".to_string()
    };

    // The skeleton that is generated by libbpf gives the bits,
    //which are valid utf, as [i8] (a.k.a a bare slice).
    // We need this to be &[u8] so that it can be converted to a str
    let comm = unsafe { event.comm.align_to::<u8>() }.1;
    let filename = unsafe { event.filename.align_to::<u8>() }.1;
    println!(
        "{:8} {:16} {} {}",
        now,
        event.pid,
        str::from_utf8(comm).unwrap(),
        str::from_utf8(filename).unwrap()
    );
    0
}

// Might need to add this to every userspace ebpf program
fn bump_memlock_rlimit() -> Result<()> {
    let rlimit = libc::rlimit {
        rlim_cur: 128 << 20,
        rlim_max: 128 << 20,
    };

    if unsafe { libc::setrlimit(libc::RLIMIT_MEMLOCK, &rlimit) } != 0 {
        bail!("Failed to increase rlimit");
    }

    Ok(())
}

fn main() -> Result<()> {
    // TODO: Add build script using libbpf-cargo::SkeletonBuilder
    // simple();
    // TODO: Use libbpf-rs to access the info
    let mut skel_builder = SimpleSkelBuilder::default();

    bump_memlock_rlimit()?;

    let mut open_skel = skel_builder.open()?;

    // TODO: Pass the args here
    // TODO: Explain what the args are and what theyre used for

    open_skel.rodata_mut().target_ino = 0;
    // Loads the program in to the kernel
    let mut simple = open_skel.load()?;

    simple.attach()?;
    println!("ATTACHED");
    let mut rb_builder = RingBufferBuilder::new();
    let mut binding = simple.maps_mut();
    rb_builder.add(binding.rb(), handle_event)?;

    let rb = rb_builder.build()?;

    loop {
        rb.poll(Duration::from_millis(100))?;
    }
    // let perf = PerfBufferBuilder::new(map)
    Ok(())
}
